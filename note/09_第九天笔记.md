# 第九天笔记



## 1. 指针相关的概念

* 指针:就是一个指针变量,指向了内存地址
* 地址:内存分为多个存储单元,每个存储单元都有自己的编号,就是地址
* 指针指的是指针变量,可以进行加减整数,自增和自减及相加赋值和相减赋值操作
* 地址可以进行加减整数操作,但是不能自增和自减及相加赋值和相减赋值操作
* 指针可以间接访问变量或者常量或者数组中的数据
* 关于32位的操作系统中内存地址占4个字节,64位的操作系统中内存地址占8个字节

## 2. 指针声明及定义的相关语法

* 指针变量的声明语法: 数据类型 * 指针变量名 =[初始值];

  ```
  int num = 10;
  int *ptr = &num;
  
  double d = 12.45;
  double * ptr2 = &d;
  ```

* 指针变量声明的三种写法:

  ```
  int *ptr1;
  int * ptr2;
  int* ptr3;
  ```

* 取值符号: 可以叫间接引用运算符号,可以叫解引用运算符,符号: *

* 取址符号:取地址符号,符号:&

## 3. 指针的运算相关

* 指针可以进行加减整数运算

  * 指针变量可以直接进行加一个整数或者减一个整数的计算,向后移动n个单位或者向前移动n个单位(一个指针变量加减一个整数n,其实就是加减这个整数n*数据类型的字节数,可以说:该指针向后或者向前移动了多少个字节数,其实就是移动的字节数除以数据类型的字节数得到的是对应的一个整数单位)

  * ```
    int nums[]={1,2,3,4,5,6,7,8,9};
    int *ptr =nums[0];
    printf("%p,%d",ptr+2,*(ptr+2));
    // 此时ptr指针变量向后移动了2*4个字节,
    // 计算思路:2*4--->移动的总字节数:8个
    // 8/4------2
    // 此时ptr指针变量向后移动了2个单位
    // 移动了多少个字节,如果要想换算成单位,移动的总字节数/数据的字节数---->得到的是n个单位
    
    ```

  * 内存地址也可以进行加减整数运算,没有改变内存地址的值,而是改变了移动的方向/指向

  * ```
    int nums[]={1,2,3,4,5,6,7,8};
    printf("%p,%d\n",&nums[0]+2,*(&nums[0]+2));
    ```

* 指针可以进行自增和自减运算

  * 指针可以进行自增和自减运算:改变了该指针变量中的指向,自增和自减也相当于在向后或者向前移动指向

    ```
    int nums[]={10,20,30,40,50}:
    int *ptr = &nums[0]; // ptr指针变量指向了数组中第一个元素的内存地址
    ptr++; // ptr指针变量指向了数组中第二个元素的内存地址
    // &nums[0]++; // 报错,原因:内存地址值不能改变
    ptr--;  ptr指针变量指向了数组中第一个元素的内存地址
    ```

* 同类型指针可以相减运算

  * 指针变量之间可以相减,但是最好是使用相同类型的之中怎进行相减的操作,得到的是两个指针相差的元素个数(相减后的字节数除以数据字节数得到的是相差的元素个数)

  * ```
    double d1 =12.3,d2=23.1;
    double *ptr1=&d1;
    double *ptr2=&d2;
    printf("%d\n",d1-d2); // 1 相差1个元素个数
    printf("%d\n",d2-d1); // -1 相差1个元素个数
    ```

  * 一定要相同类型的指针进行运算才合理

* 指针可以进行比较运算:指针变量中存储的内存地址可以相互的进行比较,>,<,>=,<=,==,!=,比较的结果是布尔类型

  * ```
    int nums[5]={10,20,30,40,50};
    int *ptr1 = &nums[0];
    int *ptr2 = &nums[3];
    printf("ptr1>ptr2的结果:%d\n",ptr1>ptr2); // 0
    ```

## 4. 指针和数组

* 指针:就是一个指针变量，指向了一个内存地址

* 数组:就是一组相同类型数据的组成.

* 指针变量是可以指向数组中任意一个元素的内存地址的

  * ```
    int nums[]={10,20,30,40};
    int *ptr1 = nums; // ptr1指向了数组的内存地址(此时可以看成是指向了数组中第一个元素的内存地址)
    int *ptr2 =&nums[0]; // ptr2指向了数组中第一个元素的内存地址
    int *ptr3 =&nums[1];// ptr3指向了数组中第二个元素的内存地址
    ```

* 数组名如果直接使用,可以当成是数组使用,也可以当成数组中第一个元素内存地址使用

  * sizeof(数组名); 计算的是数组的总字节数

  * sizeof(nums[0]);  第一个元素的字节数

  * sizeof(&nums[0]);计算的是该内存地址占的字节数

  * 移动指向: 内存地址加一个整数:

    * ```
      数组名+1 从第一个元素的内存地址移动到了第二个元素的内存地址(指向改变)
      &nums[0]+1; 从第一个元素的内存地址移动到了第二个元素的内存地址(指向改变)
      ```

    * ```
      &数组名+1 从数组首地址直接移动了整个数组的总字节数的位置
      int nums[3]={1,2,3};
      &nums+1:移动了12个字节
      下面的都是从第一个元素移动了第二个元素
      nums+1: 移动了4个字节 
      &nums[0]+1 : 移动了4个字节
      &数组名得到的是数组的内存地址,是不能当成数组中第一个元素的内存地址使用的
      ```

    * ```
        int nums[] = {1, 2, 3, 4, 5};
        for (int i = 0; i < 5; i++)
        {
          printf("%p,%d\n", &nums[i], nums[i]);
        }
        printf("%p,%d\n", &nums + 1, *(&nums + 1)); 移动的是整个数组的总字节数
        printf("%p,%d\n", &nums[0] + 1, *(&nums[0] + 1)); 移动到了第二个元素位置
        printf("%p,%d\n", nums + 1, *(nums + 1)); // 移动到了第二个元素位置
      ```

    * 

* 指针数组:就是一个数组,存储的是指针(就是指针变量,指向了内存地址),就是一个数组,里面存储了内存地址

  * 指针数组的声明语法:

  * 数据类型 * 指针数组名[长度];

  * ```
    int a=10,b=20,c=30;
    int *arr_ptr[3]={&a,&b,&c}; 指针数组
    ```

* 数组指针:就是一个指针变量,指向了数组的内存地址

  * ```
    int nums[3]={10,20,30};
    nums ---中存储了数组的内存地址,但是这个内存地址和数组中第一个元素的内存地址一样,也可以当成第一个元素内存地址使用
    &nums---中存储了数组的内存地址(真正的数组的内存地址),虽然这个地址和数组中第一个元素的内存地址一样,但是,不能当成第一个元素的内存地址使用
    nums+1;移动到了第二个元素的内存地址
    &nums[0]+1;移动到了第二个元素的内存地址
    &nums+1;移动了整个数组的总字节数后的内存地址
    int *ptr1 =nums; // ptr1是指针变量,指向了数组中第一个元素的内存地址
    int *ptr2 =&nums[0]; // ptr2是指针变量,指向了数组中第一个元素的内存地址
    int (*ptr3)[3]=&nums; // ptr3指向了数组的内存地址
    ```

* 字符指针:就是一个指针,指向了字符串/指向了字符串的内存地址/指向了字符数组的内存地址/指向了字符

* 字符数组:就是一个数组,里面存储了很多的字符,可以看成是字符串,指向不能改变,可以通过索引改里面的某个数据

* 字符指针:可以理解为是一个字符串,指向是可以改变的,但是不能通过索引改里面的某个数据

  * ```
    char chs1[5]={'a','b','c','d','\0'};
    chs1={'h','e','l','l','\0'}; 改不了,数组的指向改不了
    但是可以通过索引改值
    chs1[3]='t';
    字符指针
    char *chs2="abcdef";
    chs2="defaefase"; // 可以改指向
    chs2[3]='A'; // 不行,不能通过索引修改某个位置的数据
    ```

  * 